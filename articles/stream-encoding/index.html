<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>The zoo of binary-to-text encoding schemes - Vorakl's notes</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=robots content=all><link href=https://vorakl.com/articles/stream-encoding/ rel=canonical><meta name=description content="A stream encoding algorithm with a variable base (16, 32, 36, 64, 58, 85, 94)"><link rel=stylesheet href="https://vorakl.com/theme/bootstrap-pygments.bundle.min.css?v=1747460791"><link rel=alternate type=application/atom+xml href=https://vorakl.com/atom.xml title="Vorakl's notes"><meta name=theme-color content=#205081><link rel="shortcut icon" href="/favicon.ico?v=1747460791"><link rel=apple-touch-icon sizes=180x180 href="/favicon/apple-touch-icon.png?v=1747460791"><link rel=icon type=image/png sizes=32x32 href="/favicon/favicon-32x32.png?v=1747460791"><link rel=icon type=image/png sizes=16x16 href="/favicon/favicon-16x16.png?v=1747460791"><link rel=manifest href="/favicon/manifest.json?v=1747460791"><meta name=apple-mobile-web-app-title content="Vorakl's notes"><meta name=application-name content="Vorakl's notes"></head> <body> <div class=navbar> <div class=navbar-inner> <div class=container> <a href=https://vorakl.com/ class=brand>Vorakl's notes</a> <div class=nav-collapse> <ul class="nav pull-right"> <!-- <li class="divider-vertical"></li> --> <li><a href=https://vorakl.com/pages/contacts/ >Contacts</a></li> <li><a href=https://vorakl.com/pages/about/ >About</a></li> <!-- <li class="divider-vertical"></li> --> </ul> </div> </div> </div> </div> <div class=container> <div class=content> <div class=row> <div class=span12> <div class=article> <div class=content-title> <h1>The zoo of binary-to-text encoding schemes</h1> <div class="well small">on 2020-05-13 in <a href=https://vorakl.com/categories/article/ >article</a> about <a href=https://vorakl.com/tags/cs/ >cs</a> <a href=https://vorakl.com/tags/programming/ >programming</a> <a href=https://vorakl.com/tags/binary-to-text/ >binary-to-text</a> <a href=https://vorakl.com/tags/encoding/ >encoding</a> ~15 min read </div> <p><h3 style="text-decoration-line: none">A stream encoding algorithm with a variable base (16, 32, 36, 64, 58, 85, 94)</h3></p> </div> <div class=content><p>In <a href=https://vorakl.com/articles/base94/ class="reference external">the previous article</a>, I discussed the use of <a class="reference external" href=https://en.wikipedia.org/wiki/Positional_notation>the positional numeral system</a> for the purpose of <a class="reference external" href=https://en.wikipedia.org/wiki/Binary-to-text_encoding>binary-to-text translation</a>. That method represents a binary file as a single big number with the <a class="reference external" href=https://en.wikipedia.org/wiki/Radix>radix</a> 256 and then converts this big number to another one with an arbitrary radix (base) in a range from 2 to 94. Although this approach gives the minimum possible size overhead, unfortunately, it also has a number of downsides which make it hardly usable in a real-world situation. In this article, I'll show what is used in practice, which encodings could be found in the wild, and how to build your own encoder.</p> <div class=line-block> <div class=line><br></div> </div> <div class=section id=what-s-wrong-with-the-positional-single-number-encoding> <h2>What's wrong with the positional single number encoding?</h2> <p>The main issue with converting a file as a big number in <em>radix 256</em> to another big number with a smaller radix is that you need to read the whole file, load it to the memory and build actually that big number from each byte of the file. To construct a number, the <a class="reference external" href=https://en.wikipedia.org/wiki/Bit_numbering#Least_significant_byte>Least Significant Byte</a> (LSB), which is the last byte of a file, needs to be read and loaded. Although, there is not always enough memory to load a whole file as well as there is not always the whole file is available at any given time. For instance, if it's being transmitted over a network and only a small amount of bytes from the beginning (from the <a class="reference external" href=https://en.wikipedia.org/wiki/Bit_numbering#Most_significant_byte>Most Significant Byte</a>, MSB) has been loaded. This issue is usually addressed by processing a file as a <strong>stream of bytes</strong>, in chunks, which then are being converted in the same way (by converting a number from one base to another). These chunks are much smaller and, ideally, fit the CPU registers' size (up to 8 bytes). The only question here is how to find the best size and ratio of such chunks (input and output) to keep the size overhead as closely as possible to a minimum available by treating files as big numbers.</p> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=what-s-the-essence-of-a-positional-numeral-system> <h2>What's the essence of a positional numeral system?</h2> <p>In the positional numeral systems, everything turns around a <em>radix</em> (base) which shows how many different symbols are used to represent values. The actual glyph doesn't matter. Only their quantity. All these symbols are grouped in an alphabet (a table) where every symbol is defined by its own position, and this position represents its value. As long as counting starts from 0, the maximum symbol's value, in any numeral system, is always <em>radix - 1</em>. For instance, in the numeral system with a <em>radix 10</em> (Decimal), the maximum value has a symbol '9'. But, for a system with a <em>radix 2</em> (Binary), the maximum value has a symbol '1'. When symbols from an alphabet appear as a part of a number, they are called <em>digits</em>. A digit's position, in this case, is called <em>index</em> and defines the power of a radix while its value (position in the alphabet) defines a coefficient within the power of that radix.</p> <div class=line-block> <div class=line><br></div> </div> <p><em>The first crucial conclusion</em> here is that any number, represented in some positional numeral system, gets its meaning only when is known its radix.</p> <div class=line-block> <div class=line><br></div> </div> <p><em>The second conclusion</em> is not so obvious. Humans in most cases nowadays use the Decimal numeral system. Numbers gain more sense for them when they are represented as Decimal numbers and this is the system that is used the most for calculations. To any symbol in an alphabet is assigned its certain position which is a number with some radix. In most cases, this radix is 10 (Decimal). The Decimal numeral system is a temporary system that is used for converting one numeral system to another. Every time, when a number is defined by a radix, this radix is Decimal, no matter what's the radix of a number. Every time, when there is a need to convert a number X with radix M to a number Y with radix M, both numbers (X and Y) are represented by some certain alphabets (which define symbols with values), but their radixes (M and N) are always represented in Decimal system, thus, Decimal system is used as an intermediate numeral system to which a number X is converted first, and then the intermediate number is converted to a number Y. The intermediate numeral system could have been any radix, but <em>radix 10</em> is what people use for calculations and that's what can be found in most converters implementations.</p> <div class=line-block> <div class=line><br></div> </div> <p><em>The third conclusion</em> is even more important. Symbols don't bring any value, only their position in the alphabet. This means we need to know not only an actual number's representation but also its radix and an alphabet - the table that contains symbols assigned to values (position within the table). A good example is <a class="reference external" href=https://tools.ietf.org/html/rfc4648#page-11>an alphabet of 16 symbols for Hexadecimal numbers</a> (<em>radix 16</em>). There are first 10 digits linked to equivalent values, so the symbol '0' is linked to 0, '1' to 1, and so on up to the symbol '9' linked to 9. The rest 6 values (from 10 to 15) linked to English letter symbols (from 'A' to 'F'). And again, these values (positions in the table) are all Decimal numbers (<em>radix 10</em>). By the way, the table could have been different, but that's what is used by convention, so anyone is able to interpret Hexadecimal numbers in the same way.</p> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=where-does-the-overhead-come-from> <h2>Where does the overhead come from?</h2> <p>Let's take a look at a few examples. This is a number '123' that is represented by three symbols, but until we know a radix, it is not possible to understand its value. If the radix is 10 then it is 'one hundred twenty three' in the Decimal system and it can be calculated by <a class="reference external" href=https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system>the formula</a> for converting a numeral system with any radix to <em>radix 10</em> (because all numbers in this formula have radix 10): <tt class="docutils literal">1*10^2 + 2*10^1 + 3*10^0 = 123</tt>. If the radix is 8, then it is an Octal system and it is constructed as <tt class="docutils literal">1*8^2 + 2*8^1 + 3*8^0</tt> which gives us a Decimal number 83. So, <em>'123 base 8'</em> equals to <em>'83 base 10'</em>. It is worth noticing that converting a number to a higher radix leads to lower a number of symbols needed for its representation. The converse is also true. If a number 83 with a <em>radix 10</em> is converted to a <em>radix 2</em>, it gets a form '1010011'. Notice, the radix is changed from 10 to 2 and the number of symbols changed from 2 to 7! As lower a radix gets, as more symbols appear in representation.</p> <div class=line-block> <div class=line><br></div> </div> <p>Let's get back to binary files. What we can determine as 'symbol representation' or 'digits', 'alphabet', and 'radix' based on a structure of an ordinary file? Any file consists of bytes as it is the minimum addressable group of bits. It cannot be less than 8 bits. So, we can think about a number representation as of some amount of bytes. The chunks can vary from 1 byte to a file's size. For example, if there is only one byte, then the number consists of only one digit. One byte or 8 bits (binary digits with a <em>radix 2</em>) allows one to represent <tt class="docutils literal">2^8 = 256</tt> different numbers. That means, we can persist 256 different symbols with their positions to build an alphabet. The good news, such a table has already been standardized many years ago and called <a href=https://www.ascii-code.com/ class="reference external">ASCII</a>. And the last thing, as the alphabet size is 256 symbols then a radix is also 256. Here is our number: a number of bytes in the chunk that we are going to process are the number of digits, a radix is 256, and the coefficient has a range from 0 to 255. For example, if a group of bytes to read from a stream and process at once consists of 4 bytes (from MSB to LSB): <em>[13, 200, 3, 65]</em> then our number can be represented as a Decimal number (<em>radix 10</em>) as <tt class="docutils literal">13*256^3 + 200*256^2 + 3*256^1 + 65*256^0 = 231211841</tt></p> <div class=line-block> <div class=line><br></div> </div> <p>As it was discussed in <a href=https://vorakl.com/articles/base94/ class="reference external">the previous article</a>, we can use no more than 94 different symbols to reliably represent texts. Thus, the desired radix lies somewhere in the range from 2 to 94. Even 94 is much less than 256, so a number's representation in a new radix is likely to have more symbols. This means, in turn, that the output group will have more bytes as it is a minimum amount of data we can operate on, even if a digit represented by a symbol needs fewer bits. You'll still need to allocate the whole byte for each symbol in the new radix number representation. Some amount of bits in such bytes will never be used. This is the root of inefficiency, and that's why it's highly important to find a good ratio of output to input byte groups. For instance, the most used nowadays <a class="reference external" href=https://tools.ietf.org/html/rfc4648#section-4>Base64</a> encoding converts binary files to texts by reading 3-bytes groups from the input stream, represents them as a 3-digits number with a <em>radix 256</em> (<tt class="docutils literal">log[256^3, 2] = 24</tt> bit), and then converts this number to a 4-digits number with a <em>radix 64</em> (<tt class="docutils literal">log[64^4, 2] = 24</tt> bit), which in turn is written to the output stream as a group of 4 bytes. So, the ratio of output to input is <tt class="docutils literal">4/3 = 1.333333</tt>. In other words, the size overhead is 33.(3)%. There are a few considerations behind the logic of choosing the exact combination of input and output groups for a streaming conversion, which includes a target radix, a desirable/available alphabet, an ability to natively compute on a CPU, etc.</p> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=how-to-calculate-a-minimal-overhead> <h2>How to calculate a minimal overhead?</h2> <p>Let's calculate first, how many digits of a target base (radix) are needed to represent exactly the same number in the initial base. For instance, there is given a number 123 with a radix 10. How many bits (binary digits, a radix 2) are needed to represent the same decimal number? Every digit is a coefficient of power of a base. If it is not enough, one more base is added in power +1 to finally construct a number. Keeping in mind that counting starts from 0, if it's said that to represent some number 8 bit are needed, this means all bases in powers from 0 to 7 with their coefficients have to be summed up. Thus, to find out a number of digits needed to represent the number in some radix, we need to find an exponent, to which a new radix needs to be exponentiated. In our case, for a base-10 number 123, we need to calculate an exponent of a base-2 by using a logarithm function: <tt class="docutils literal">log[123, 2] = 6.9425145</tt>. This means, to represent a number 123 with base 10, a little bit less than 7 bits will be enough. All computer systems operate on a set of <a href=https://vorakl.com/articles/numbers/ class="reference external">natural numbers</a> only. It is not possible to use 6.9425145 bits as this number is an approximated value of needed bits. 6 bits apparently won't be enough (<tt class="docutils literal">2^6 = 64</tt>, which is much less than 123), so the only right approach is always to round up (by calling a <em>ceil</em> function) any non-integer values. Unfortunately, 7 bits are able to represent a bigger number (<tt class="docutils literal">2^7 = 128</tt>) and this again contributes to a final overhead.</p> <div class=line-block> <div class=line><br></div> </div> <p>Let's have a look at the Base64 again. We know already (but not why is that, yet), that this streaming system uses 3 input bytes (a 3-digit number with a <em>base 256</em>) and converts them to a number with a <em>base 64</em>. How many base-64 digits will this number contain? The answer is <tt class="docutils literal">log[256^3, 64] = 4</tt>, four digits, hence 4 symbols from the base64 alphabet.</p> <div class=line-block> <div class=line><br></div> </div> <p>While looking for the good input and output group sizes it's good to know a theoretically possible minimum of the overhead. To find it out, we need to do a similar calculation but take the minimally possible amount of input data, which is one byte (8 bits, decimal <tt class="docutils literal">2^8 = 256</tt>). For the Base64, it is <tt class="docutils literal">log[256, 64] = 1.33(3)</tt>, that is again 33.(3)%. For the <a class="reference external" href=https://tools.ietf.org/html/rfc4648#section-6>Base32</a> it is <tt class="docutils literal">log[256, 32] =&nbsp; 1.6</tt>, that is 60%. And for the <a class="reference external" href=https://tools.ietf.org/html/rfc4648#section-8>Base16</a> it is <tt class="docutils literal">log[256, 16] = 2</tt>, that is 100%. Wow! These theoretical numbers are exactly the same as practically used ratios of output bytes to input bytes give. Here are they: for the Base64 it is <tt class="docutils literal">4 / 3 = 1.33(3)</tt>, for the Base32 it is <tt class="docutils literal">8 / 5 = 1.6</tt>, and for the Base16 it is <tt class="docutils literal">2 / 1 = 2</tt>. There is one interesting fact, all these three bases (16, 32, 64) have one thing in common - they all are powers of two! This leads us to the conclusion that converting numbers within the &quot;power of two&quot; bases allows one to get the best possible ratio and match precisely an input bits group to an output bits group. Although it is not always desirable or even possible. Sometimes there is a need to use a specific alphabet, e.g. in <a class="reference external" href=https://en.wikipedia.org/wiki/Base36>Base36</a>, or the minimal overhead, e.g. in <a href=https://www.johndcook.com/blog/2019/03/05/base85-encoding/ class="reference external">Base85</a> or <a class="reference external" href=https://gist.github.com/iso2022jp/4054241>Base94</a>. All these bases are not the &quot;powers of two&quot;, so a tradeoff has to be found to minimize the overhead.</p> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=how-to-calculate-optimal-input-and-output-groups> <h2>How to calculate optimal input and output groups?</h2> <p>Alright, we've calculated a number of digits needed to represent some number in another base. But, why is that only a theoretical minimum? Why in practice it would need more? And, why would we still need to find a good ratio of output to input byte groups? To answer these questions, let's have a look at the <strong>Base85</strong> encoding. To represent 1 byte (Base256) of information in Base85, it needs <tt class="docutils literal">log[256, 85] = 1.24816852</tt> digits. But, we can't use 1.248 digits. Only positive whole numbers are available! 1 digit is neither possible (too little). Then, 2 digits are the only way to go. In other words, to represent 1 byte (with a number in Base256), in fact, we'd need 2 bytes (with a number in Base85), where ~75% of space will be wasted, as the ratio is <tt class="docutils literal">2/1 = 2</tt> and this is a 100% overhead, instead of a theoretical 24.8%. There is no point to use 1-byte input group and 2-bytes output group. Thus, there should be some good input and output groups so their ratio goes as close as possible to a calculated minimum or even match it!</p> <div class=line-block> <div class=line><br></div> </div> <p>The following approach starts from 1-byte group and using the same formula, every time checks a number of digits in the destination base. if it's not close enough, increments the input group by 1 byte and checks again. You can decide on your own, what is the applicable size of an input group and how close to the whole number up (ceil function) the output group needs to be.</p> <div class=line-block> <div class=line><br></div> </div> <p>This code goes through all bases, from 2 to 94, and prints a first found input/output group that has a delta between the number of digits and its rounded value less or equal 0.1, if any. That is, <tt class="docutils literal">ceil(x) - x &lt;=0.1</tt>. I limited an input group by 20 bytes but in reality, groups larger than 8 bytes (64bit) will require either a <a class="reference external" href=https://gist.github.com/iso2022jp/4054241>more complicated implementation</a> still based on 64bit variable types or the big number mathematics which would bring it back to the solution from <a href=https://vorakl.com/articles/base94/ class="reference external">the previous article</a>.</p> <div class=line-block> <div class=line><br></div> </div> <div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>log</span><span class=p>,</span> <span class=n>ceil</span>

<span class=k>def</span> <span class=nf>find_dec_fractions</span><span class=p>(</span><span class=n>num</span><span class=p>):</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>k</span> <span class=ow>in</span> <span class=p>[(</span><span class=n>i</span><span class=p>,</span> <span class=n>log</span><span class=p>(</span><span class=mi>256</span><span class=o>**</span><span class=n>i</span><span class=p>,</span> <span class=n>num</span><span class=p>))</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>20</span><span class=p>)]:</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>ceil</span><span class=p>(</span><span class=n>k</span><span class=p>)</span><span class=o>-</span><span class=n>k</span><span class=p>)</span><span class=o>&lt;=</span><span class=mf>0.1</span><span class=p>:</span>
            <span class=k>return</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>

<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>95</span><span class=p>):</span>
    <span class=k>try</span><span class=p>:</span>
        <span class=n>b_in</span><span class=p>,</span> <span class=n>b_out</span> <span class=o>=</span> <span class=n>find_dec_fractions</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
    <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
        <span class=k>continue</span>
    <span class=k>print</span><span class=p>(</span><span class=n>f</span><span class=s1>&#39;Base{i}: output/input {b_out} / {b_in}; Ratio: {ceil(b_out)} / {b_in} = {ceil(b_out)/b_in}&#39;</span><span class=p>)</span>
</pre></div> <div class=line-block> <div class=line><br></div> </div> <div class=highlight><pre><span></span>Base2: output/input 8.0 / 1; Ratio: 8 / 1 = 8.0
Base3: output/input 95.90132254286152 / 19; Ratio: 96 / 19 = 5.052631578947368
Base4: output/input 4.0 / 1; Ratio: 4 / 1 = 4.0
Base6: output/input 30.948224578763327 / 10; Ratio: 31 / 10 = 3.1
Base7: output/input 19.94760247804924 / 7; Ratio: 20 / 7 = 2.857142857142857
Base8: output/input 8.0 / 3; Ratio: 8 / 3 = 2.6666666666666665
Base9: output/input 42.9032232428591 / 17; Ratio: 43 / 17 = 2.5294117647058822
Base10: output/input 40.940079410301436 / 17; Ratio: 41 / 17 = 2.411764705882353
Base11: output/input 6.937555831629307 / 3; Ratio: 7 / 3 = 2.3333333333333335
Base12: output/input 8.926174260836154 / 4; Ratio: 9 / 4 = 2.25
Base13: output/input 12.971431412511347 / 6; Ratio: 13 / 6 = 2.1666666666666665
Base14: output/input 18.910766522677935 / 9; Ratio: 19 / 9 = 2.111111111111111
Base15: output/input 38.905619771091956 / 19; Ratio: 39 / 19 = 2.0526315789473686
Base16: output/input 2.0 / 1; Ratio: 2 / 1 = 2.0
Base17: output/input 1.957204336945808 / 1; Ratio: 2 / 1 = 2.0
Base18: output/input 1.9184997325450517 / 1; Ratio: 2 / 1 = 2.0
Base19: output/input 16.949441762397953 / 9; Ratio: 17 / 9 = 1.8888888888888888
Base20: output/input 12.957179936946513 / 7; Ratio: 13 / 7 = 1.8571428571428572
Base21: output/input 10.928171937453742 / 6; Ratio: 11 / 6 = 1.8333333333333333
Base22: output/input 8.969752968703016 / 5; Ratio: 9 / 5 = 1.8
Base23: output/input 15.916660520940269 / 9; Ratio: 16 / 9 = 1.7777777777777777
Base24: output/input 6.97933734353701 / 4; Ratio: 7 / 4 = 1.75
Base25: output/input 18.949768555229294 / 11; Ratio: 19 / 11 = 1.7272727272727273
Base26: output/input 11.913778998988336 / 7; Ratio: 12 / 7 = 1.7142857142857142
Base27: output/input 26.919669485715517 / 16; Ratio: 27 / 16 = 1.6875
Base28: output/input 4.992350344236227 / 3; Ratio: 5 / 3 = 1.6666666666666667
Base29: output/input 4.940323979050427 / 3; Ratio: 5 / 3 = 1.6666666666666667
Base30: output/input 17.933964143964545 / 11; Ratio: 18 / 11 = 1.6363636363636365
Base31: output/input 12.91834154125439 / 8; Ratio: 13 / 8 = 1.625
Base32: output/input 8.0 / 5; Ratio: 8 / 5 = 1.6
Base33: output/input 7.929594526822421 / 5; Ratio: 8 / 5 = 1.6
Base35: output/input 10.917705226052034 / 7; Ratio: 11 / 7 = 1.5714285714285714
Base36: output/input 13.926701060443497 / 9; Ratio: 14 / 9 = 1.5555555555555556
Base37: output/input 19.963706880682256 / 13; Ratio: 20 / 13 = 1.5384615384615385
Base38: output/input 25.91499209004118 / 17; Ratio: 26 / 17 = 1.5294117647058822
Base41: output/input 2.9864385798230937 / 2; Ratio: 3 / 2 = 1.5
Base42: output/input 2.9671843746459023 / 2; Ratio: 3 / 2 = 1.5
Base43: output/input 2.9486213303792987 / 2; Ratio: 3 / 2 = 1.5
Base44: output/input 2.930708014618138 / 2; Ratio: 3 / 2 = 1.5
Base45: output/input 2.913406407519012 / 2; Ratio: 3 / 2 = 1.5
Base46: output/input 15.93174851664354 / 11; Ratio: 16 / 11 = 1.4545454545454546
Base47: output/input 12.96225551928187 / 9; Ratio: 13 / 9 = 1.4444444444444444
Base48: output/input 22.918685664133292 / 16; Ratio: 23 / 16 = 1.4375
Base49: output/input 9.97380123902462 / 7; Ratio: 10 / 7 = 1.4285714285714286
Base50: output/input 9.922293927591243 / 7; Ratio: 10 / 7 = 1.4285714285714286
Base51: output/input 16.92397770133268 / 12; Ratio: 17 / 12 = 1.4166666666666667
Base53: output/input 6.983337201921797 / 5; Ratio: 7 / 5 = 1.4
Base54: output/input 6.9506137148575995 / 5; Ratio: 7 / 5 = 1.4
Base55: output/input 6.918787617803083 / 5; Ratio: 7 / 5 = 1.4
Base56: output/input 17.9083251145862 / 13; Ratio: 18 / 13 = 1.3846153846153846
Base57: output/input 10.97226243673046 / 8; Ratio: 11 / 8 = 1.375
Base58: output/input 10.925265898478088 / 8; Ratio: 11 / 8 = 1.375
Base59: output/input 14.959262233248435 / 11; Ratio: 15 / 11 = 1.3636363636363635
Base60: output/input 18.960906451063522 / 14; Ratio: 19 / 14 = 1.3571428571428572
Base61: output/input 22.93138142177215 / 17; Ratio: 23 / 17 = 1.3529411764705883
Base64: output/input 4.0 / 3; Ratio: 4 / 3 = 1.3333333333333333
Base65: output/input 3.9851435091825076 / 3; Ratio: 4 / 3 = 1.3333333333333333
Base66: output/input 3.9706212940573997 / 3; Ratio: 4 / 3 = 1.3333333333333333
Base67: output/input 3.9564205613318486 / 3; Ratio: 4 / 3 = 1.3333333333333333
Base68: output/input 3.942529199089205 / 3; Ratio: 4 / 3 = 1.3333333333333333
Base69: output/input 3.9289357306851747 / 3; Ratio: 4 / 3 = 1.3333333333333333
Base70: output/input 3.9156292724042583 / 3; Ratio: 4 / 3 = 1.3333333333333333
Base71: output/input 3.9025994945192193 / 3; Ratio: 4 / 3 = 1.3333333333333333
Base72: output/input 12.966121951449782 / 10; Ratio: 13 / 10 = 1.3
Base73: output/input 12.92443739543971 / 10; Ratio: 13 / 10 = 1.3
Base74: output/input 21.90208895887644 / 17; Ratio: 22 / 17 = 1.2941176470588236
Base75: output/input 8.990468784305198 / 7; Ratio: 9 / 7 = 1.2857142857142858
Base76: output/input 8.962972102269996 / 7; Ratio: 9 / 7 = 1.2857142857142858
Base77: output/input 8.935999277516537 / 7; Ratio: 9 / 7 = 1.2857142857142858
Base78: output/input 8.909533240680473 / 7; Ratio: 9 / 7 = 1.2857142857142858
Base79: output/input 13.959876384572452 / 11; Ratio: 14 / 11 = 1.2727272727272727
Base80: output/input 13.919804002700841 / 11; Ratio: 14 / 11 = 1.2727272727272727
Base81: output/input 18.927892607143722 / 15; Ratio: 19 / 15 = 1.2666666666666666
Base82: output/input 23.908573597131127 / 19; Ratio: 24 / 19 = 1.263157894736842
Base85: output/input 4.9926740807112 / 4; Ratio: 5 / 4 = 1.25
Base86: output/input 4.979564524879807 / 4; Ratio: 5 / 4 = 1.25
Base87: output/input 4.966674008644963 / 4; Ratio: 5 / 4 = 1.25
Base88: output/input 4.953996247544582 / 4; Ratio: 5 / 4 = 1.25
Base89: output/input 4.941525209635524 / 4; Ratio: 5 / 4 = 1.25
Base90: output/input 4.929255102536434 / 4; Ratio: 5 / 4 = 1.25
Base91: output/input 4.917180361275656 / 4; Ratio: 5 / 4 = 1.25
Base92: output/input 4.905295636885699 / 4; Ratio: 5 / 4 = 1.25
Base93: output/input 15.904186303494539 / 13; Ratio: 16 / 13 = 1.2307692307692308
Base94: output/input 10.984670683283468 / 9; Ratio: 11 / 9 = 1.2222222222222223
</pre></div> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=conclusions> <h2>Conclusions</h2> <p>This output provides several interesting insights:</p> <ol class="arabic simple"> <li>All the &quot;power of two&quot; bases, e.g. Base16/32/64, always have a whole number of required digits, as the source base is also the &quot;power of two&quot;! This simple fact makes it even easier to calculate the optimal groups by using a method of finding <a class="reference external" href=https://en.wikipedia.org/wiki/Least_common_multiple>LCM (Least Common Multiple)</a>, also shown in <a href=https://vorakl.com/articles/base94/ class="reference external">the previous article</a>.</li> <li>There are a few groups of adjacent bases that require the same number of digits but are different by the size of their alphabets. It seems reasonable to prefer smaller alphabets, as less special symbols lead to better readability, e.g. when an encoded text needs to be used within a value of some variable in a programming language, or read verbally over a voice channel (encoded license keys).</li> <li>Usually, the size of binary files, and especially executable files, appears to be evenly divisible by 4. This makes reasonable to use bases, that have 4-byte input groups. Then, there will be fewer chances to convert files, where the last byte group doesn't have all the needed data to perform the conversion. Although, even if it happens, it usually addresses using padding by NULL-symbols. The <a class="reference external" href=https://tools.ietf.org/html/rfc4648#section-3.2>Base32 and Base64 for padding</a> uses one extra symbol (out of the alphabet) '=', and <a class="reference external" href=https://en.wikipedia.org/wiki/Ascii85#Adobe_version>Ascii85 uses an even smarter approach</a>, with no extra symbols on the output stream.</li> <li>Among all bases in the list, there is one outstanding base, Base85. It uses 4 input bytes that aligned with the average case of binary files. 5 output bytes give only 25% overhead which provides better efficiency than Base64 (with its 33.3%). Both groups fit CPU's registers all modern computers. All these factors make this encoding much more optimal for a binary-to-text encoding than commonly used nowadays on the Internet encoding - Base64 or some times ago on the <a class="reference external" href=https://en.wikipedia.org/wiki/FidoNet>FidoNet</a> - <a class="reference external" href=https://en.wikipedia.org/wiki/Uuencoding>UUEncode</a> (which internally is the same Base64). With the differences in alphabets, Base85 is used in <a class="reference external" href=https://en.wikipedia.org/wiki/Ascii85>PDF</a>, <a class="reference external" href=https://github.com/git/git/blob/53f9a3e157dbbc901a02ac2c73346d375e24978c/base85.c>Git</a>, <a href=https://rfc.zeromq.org/spec/32/ class="reference external">ZeroMQ</a>, and also implemented in the <a class="reference external" href=https://github.com/python/cpython/blob/3.8/Lib/base64.py#L416>Standard Python Library base64</a>.</li> <li>There are also known to be used <a class="reference external" href=https://www.crockford.com/base32.html>Crockford-Base32</a>, <a class="reference external" href=https://en.wikipedia.org/wiki/Base36>Base36</a>, and <a href=https://www.johndcook.com/blog/2019/03/04/base-58-encoding-and-bitcoin-addresses/ class="reference external">Base58</a> in special applications, as efficiency is not the main consideration for their use and they meet other requirements.</li> </ol> <div class=line-block> <div class=line><br></div> </div> <!-- Links --> </div> </div> </div> <div class=article style="text-align: center; font-size: 1.1em; font-style: italic"> Found a <span style="color: red; font-weight: bold">bug</span> or <span style="color: red; font-weight: bold">typo</span>? Please, send me <a href=/pages/feedback/ >feedback</a> or submit a <a href=https://github.com/vorakl/vorakl.github.io/blob/master/src.docs/content/articles/stream-encoding.rst>PR on Github</a>. </div> <div class=article> <div class="well small"><h5>This is my personal blog. All ideas, opinions, examples, and other information that can be found here are my own and belong entirely to me. This is the result of my personal efforts and activities at my free time. It doesn't relate to any professional work I've done and doesn't have correlations with any companies I worked for, I'm currently working, or will work in the future.</h5></div> </div> </div> </div> </div> <footer> <div class=container> <div class=row> <div class=span5> <span class=pull-left> &copy; 2020 <a href=https://vorakl.com/pages/about/ >vorakl</a> All Rights Reserved </span> </div> <div class=span7> <div class=pull-right> Powered by <a href=https://github.com/getpelican/pelican>Pelican</a> and <a href=https://github.com/vorakl/aves>Aves</a> theme </div> </div> </div> </div> </footer> </div> </body> </html>