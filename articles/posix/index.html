<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>A few facts about POSIX - Vorakl's notes</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=robots content=all><link href=https://vorakl.com/articles/posix/ rel=canonical><meta name=description content="A journey to portable software"><link rel=stylesheet href="https://vorakl.com/theme/bootstrap-pygments.bundle.min.css?v=1747460791"><link rel=alternate type=application/atom+xml href=https://vorakl.com/atom.xml title="Vorakl's notes"><meta name=theme-color content=#205081><link rel="shortcut icon" href="/favicon.ico?v=1747460791"><link rel=apple-touch-icon sizes=180x180 href="/favicon/apple-touch-icon.png?v=1747460791"><link rel=icon type=image/png sizes=32x32 href="/favicon/favicon-32x32.png?v=1747460791"><link rel=icon type=image/png sizes=16x16 href="/favicon/favicon-16x16.png?v=1747460791"><link rel=manifest href="/favicon/manifest.json?v=1747460791"><meta name=apple-mobile-web-app-title content="Vorakl's notes"><meta name=application-name content="Vorakl's notes"></head> <body> <div class=navbar> <div class=navbar-inner> <div class=container> <a href=https://vorakl.com/ class=brand>Vorakl's notes</a> <div class=nav-collapse> <ul class="nav pull-right"> <!-- <li class="divider-vertical"></li> --> <li><a href=https://vorakl.com/pages/contacts/ >Contacts</a></li> <li><a href=https://vorakl.com/pages/about/ >About</a></li> <!-- <li class="divider-vertical"></li> --> </ul> </div> </div> </div> </div> <div class=container> <div class=content> <div class=row> <div class=span12> <div class=article> <div class=content-title> <h1>A few facts about POSIX</h1> <div class="well small">on 2024-04-23 in <a href=https://vorakl.com/categories/article/ >article</a> about <a href=https://vorakl.com/tags/it/ >it</a> <a href=https://vorakl.com/tags/os/ >os</a> <a href=https://vorakl.com/tags/programming/ >programming</a> ~8 min read </div> <p><h3 style="text-decoration-line: none">A journey to portable software</h3></p> </div> <div class=content><p><a class="reference internal" href=#summary>TLDR: quick summary of the article</a></p> <div class=line-block> <div class=line><br></div> </div> <div class=section id=how-did-we-get-there> <h2>How did we get there?</h2> <div class=line-block> <div class=line><br></div> </div> <p>In the early days of computing, programmers could only dream of portability. All programs were written directly in machine code for each computer architecture they were intended to run on. <a class="reference external" href=https://en.wikipedia.org/wiki/Assembly_language>Assembly languages</a> with mnemonic names for each CPU instruction and other goodies made programmers' lives a little easier, but programs were still architecture-specific. Operating systems (OS) had not yet been invented, so a program not only controlled the entire computer system, it also had to initialize and manage the peripherals. In fact, such bare-metal programs implemented drivers for every device they used. And every time a program needed to run on hardware with a different architecture, it was literally rewritten to accommodate a difference in the <a class="reference external" href=https://en.wikipedia.org/wiki/Instruction_set_architecture>CPU instruction</a> set, memory layout, and so on.</p> <div class=line-block> <div class=line><br></div> </div> <p>This is exactly what happened with Unix, which was originally written in assembly language by Ken Thompson over 50 years ago. The first versions of Unix were written for the <a class="reference external" href=https://en.wikipedia.org/wiki/PDP-7>PDP-7</a> platform, and porting it to the <a class="reference external" href=https://en.wikipedia.org/wiki/PDP-11>PDP-11</a> meant rewriting the code. When Dennis Ritchie created the C programming language, and <a class="reference external" href=https://www.invent.org/sites/default/files/2019-02/Inductee-UNIX_Thompson_Ritchie.jpg>together they</a> rewrote most of the Unix code in it, software portability suddenly became possible. There are two main reasons for this. First, the code written in a high-level programming language is platform-agnostic, because compilers translate it into the assembly language for a target architecture. This is even more important for target systems based on <a class="reference external" href=https://en.wikipedia.org/wiki/Reduced_instruction_set_computer>RISC CPUs</a>, as they require writing significantly more assembly instructions than <a class="reference external" href=https://en.wikipedia.org/wiki/Complex_instruction_set_computer>CISC CPU</a> architecture. Even porting Unix to another platform was mostly a matter of adapting the architecture-dependent parts of the code. On the other hand, the operating system itself abstracts away all hardware specifics from a user program. Programmers don't have to implement multitasking, memory management, or drivers for different devices as they used to, because it's all part of the OS kernel and runs in the kernel address space. In contrast, user programs run in the user address space and access all of the features provided by the OS through the the system call interface. In <a class="reference external" href=https://en.wikipedia.org/wiki/Real-time_operating_system>Real-time OSes</a>, such as <a href=https://www.zephyrproject.org/ class="reference external">Zephyr OS</a>, it's <a class="reference external" href="https://www.youtube.com/watch?v=4_uL43V79xw">slightly different</a>, but the idea of memory isolation and protection for user programs is preserved. This leads to two conclusions:</p> <ul class=simple> <li><em>User programs become portable when they are written in a high-level programming language for a particular OS</em>. Once both requirements are met, programs are compiled into instructions for a target CPU and linked with system functions provided by the <a class="reference external" href=https://en.wikipedia.org/wiki/C_standard_library>libc</a> and OS-specific libraries to access the underlying hardware.</li> <li>Portability is intended to be achieved <strong>at the source code level</strong>.</li> </ul> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=the-birth-of-posix> <h2>The birth of POSIX</h2> <div class=line-block> <div class=line><br></div> </div> <p>This could have been the end of the story, but something fateful happened. Due to a legal restriction, AT&amp;T was not allowed to sell Unix, so there was no money to be made from the newly born OS, which became increasingly popular after it was introduced to the world. However, it turned out to be possible to distribute Unix to any interested organization for the cost of the media. That's how Unix got to Berkeley in 1974 and many other places, leading to the creation of a number of OS derivatives. Some of the best known and still popular today are OSes based on the software distributed by Berkeley (BSD), e.g. FreeBSD and OpenBSD. Despite sharing the same ancestors and principles, each operating system followed its own unique path. Each of these operating systems had a unique interface (API) and implementation of kernel subsystems, syscalls, different system tools, etc. Even libc, which provides common functionality and wrappers on top of syscalls, used to be very OS-specific. All of these OSes were Unix-like, but at the same time, it wasn't possible to take the source code of a program written for one OS and recompile it on another.</p> <div class=line-block> <div class=line><br></div> </div> <p>Over 35 years ago, these problems with software portability led to the emergence of the first <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/nframe.html>POSIX standard</a> in 1988. The acronym <a class="reference external" href=https://opensource.com/article/19/7/what-posix-richard-stallman-explains>was coined by Richard Stallman</a>, who added &quot;X&quot; to the end of <em>Portable Operating System Interface</em>. The <em>POSIX™</em> trademark is currently owned by <a class="reference external" href=https://www.ieee.org/about/index.html>IEEE</a>, and <em>UNIX®</em> is a registered trademark of <a class="reference external" href=https://www.opengroup.org/about-us>The Open Group</a>. It's meant to provide a <a class="reference external" href=https://www.techtarget.com/whatis/definition/POSIX-Portable-Operating-System-Interface>specification of the interface</a> that different Unix operating systems should have in common, including <a class="reference external" href=https://stackoverflow.com/a/31865755>programming languages and tools</a>. It's important to note that <strong>the interface is portable</strong>, and not the implementation.</p> <div class=line-block> <div class=line><br></div> </div> <p>This was the common ground that made it possible to compile the same source code of a user program on any OS without modification, if both sides strictly followed the same standard. And this is still true to some extent today, as most modern and widely used Unix-like systems, such as Linux, and <cite>*BSD</cite>, do not strictly and completely follow POSIX standard, but rather use it as a guide. In addition to POSIX, there is also the <a class="reference external" href=https://en.wikipedia.org/wiki/Single_UNIX_Specification>Single UNIX Specification</a> (SUS), which was consolidated with a few different POSIX standards in 2001. However, the latest SUS (SUSv4 2018) extends the latest POSIX standard (POSIX.1-2017), which is essentially its base specification, with the X/Open Curses specification. There are <a class="reference external" href=https://en.wikipedia.org/wiki/POSIX#POSIX-oriented_operating_systems>a number of operating systems, such as MacOS</a>, which are fully compliant with the POSIX and SUS standards, pass The Open Group conformance tests and can therefore be called <a href=https://www.opengroup.org/openbrand/register/ class="reference external">Unix operating systems</a>, not just Unix-like. Originally, POSIX was only created for Unix-like OSes, but over time it became so popular that its specification, in the form of the <a class="reference external" href=https://en.wikipedia.org/wiki/Operating_system_abstraction_layer>Operating System Abstraction Layer (OSAL)</a>, was partially implemented (some subset of the interface that applicable to the target system) in non-Unix OSes, such as <a class="reference external" href=https://en.wikipedia.org/wiki/Cygwin>Windows</a>, <a class="reference external" href=https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html>FreeRTOS</a>, <a class="reference external" href=https://docs.zephyrproject.org/latest/services/portability/posix/index.html>Zephyr</a>, etc.</p> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=the-posix-spec> <h2>The POSIX spec</h2> <div class=line-block> <div class=line><br></div> </div> <p>The very first standard was ratified by the IEEE in 1988 as IEEE Std 1003.1-1988, so it's called <em>POSIX.1-1988</em>. Since then, the standard has gone through several revisions, with different subsets of the specification being ratified under different names. For example, <em>POSIX.1-1990</em> (IEEE 1003.1-1990) defined <em>the system interface and computing environment</em>, <em>POSIX.2</em> (IEEE Std 1003.2-1992) defined <em>command language (shell) and tools</em>, etc. A very good and brief overview of the standard's revisions can be found in the <a class="reference external" href=https://man7.org/linux/man-pages/man7/standards.7.html>standards(7)</a> Linux man page. You may even come across references to some old revisions, such as POSIX.2, for example, when reading the <a class="reference external" href=https://git.savannah.gnu.org/cgit/bash.git/tree/jobs.c#n4269>Bash source code</a>. In 2001, POSIX.1, POSIX.2, and the Single UNIX Specification (SUS) were merged into a single document called <em>POSIX.1-2001</em>. Despite the somewhat misleading name, it does include the shell and tools specifications from POSIX.2. <strong>The latest version of the standard is POSIX.1-2017</strong>, also known as <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/nframe.html>IEEE Std 1003.1-2017</a>, which is almost identical to POSIX.1-2008.</p> <div class=line-block> <div class=line><br></div> </div> <p>The document of the standard basically describes a specification that spans over two environments (a build-time and a run-time) and is represented by a few volumes:</p> <ul class=simple> <li><a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/toc.html>Base Definitions</a>: defines common to all volumes general terms and concepts, conformant requirements (symbolic constants, options, option groups), computing environment (locales, regexp, directory structure, tty, environment variables, etc), and C-language header files which need to be implemented by the compliant systems.</li> <li><a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/idx/xsh.html>System Interfaces</a>: defines the C language standard (<a class="reference external" href=http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf>ISO C99, ISO/IEC 9899:1999</a>), system service functions, and the extension of the C standard library (libc) in terms of header files and functions.</li> <li><a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/idx/xcu.html>Shell &amp; Utilities</a>: defines a source code-level interface to the Shell Command Language (sh) and the system utilities (awk, sed, wc, cat, ...), including behavior, command line parameters, exit statuses, etc.</li> <li><a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/idx/xrat.html>Rationale</a>: includes considerations for portability, subprofiling, option groups, and additional rationale that didn't fit any other volumes.</li> </ul> <div class=line-block> <div class=line><br></div> </div> <p>The current POSIX standard defines source code-level compatibility for <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_04>only two programming languages</a>: <em>The C language (C99)</em> and <em>the shell command language</em>. However, some of the programs defined under &quot;Utilities&quot;, such as <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html>awk</a>, also have their own language. Strictly speaking, the C standard library (libc) doesn't have to implement any additional functionality (functions and headers) that is not defined by the C standard (ISO C99 in this case), but most of them do. For example, the ISO C99 standard, defines 24 header files, including math functions (&lt;math.h&gt;), standard input/output (&lt;stdio.h&gt;), date and time (&lt;time.h&gt;), signal management (&lt;signal.h&gt;), string operations (&lt;string.h&gt;), and so on. However, the latest POSIX standard, defines 82 header files and, being fully compliant with ISO C99, extends it with with POSIX threads (&lt;pthreads.h&gt;), semaphores (&lt;semaphore.h&gt;), and many others. Modern libc implementations, e.g. <a class="reference external" href=https://musl.libc.org/about.html>musl libc</a>, are also very OS-specific, providing library functions to access operating system services (wrappers for system calls). Sometimes, the overlap with the POSIX specifications leads to difficulties in implementing the POSIX abstraction layer in the non-Unix operating systems, which also use some portable standalone libc implementations with their own POSIX support, e.g. using <a href=https://keithp.com/picolibc/ class="reference external">picolibc</a> together with <a class="reference external" href=https://docs.zephyrproject.org/latest/services/portability/posix/implementation/index.html>Zephyr's POSIX library</a>.</p> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=options-and-option-groups> <h2>Options and Option Groups</h2> <div class=line-block> <div class=line><br></div> </div> <p>While POSIX standardizes the system interface (C language headers and functions), shell, and utilities, it is not necessary to follow the entire specification to be <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_03>POSIX conformant</a>. Some features in &quot;POSIX System Interfaces&quot;, &quot;POSIX Shell and Utilities&quot;, and &quot;XSI System Interfaces&quot; are optional. The <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html>&lt;unistd.h&gt; header file</a> contains definitions of the <em>standard symbolic constants</em> for <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_06>Options</a>, which reflect a particular feature, and <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_05>Option Groups</a> which define a set of related functions or options. Names of option groups, unlike options, typically do not begin with the underscore symbol. POSIX Conformant systems are intended to implement and support a set of mandatory options with one or more additional options. The symbolic constants for mandatory options should have specific values, e.g. <em>200809L</em>, while other options may be</p> <ul class=simple> <li><em>undefined or contain -1</em>, which means that the option is not supported for compilation</li> <li><em>0</em>, which means the option might or might not be supported at runtime</li> <li><em>some other value</em>, which means the option is always supported</li> </ul> <div class=line-block> <div class=line><br></div> </div> <p>These symbolic constants are used by user applications to check the availability of a particular feature. At the C source code-level, constants may be checked either at build time (in #if preprocessing directives) or at runtime, by calling one of the <em>sysconf()</em>, <em>pathconf()</em>, <em>fpathconf()</em>, or <em>confstr(3)</em> functions. In the shell source code, the <a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getconf.html>getconf</a> utility should be used for runtime checks. A very good collection of the POSIX options, their corresponding names for use as the sysconf(3) parameters, and the list of header files and functions that these options represent can be found in the <a class="reference external" href=https://man7.org/linux/man-pages/man7/posixoptions.7.html>posixoptions(7)</a> Linux man page.</p> <div class=line-block> <div class=line><br></div> </div> <p><a class="reference external" href=https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html>Subprofiling Option Groups</a> are intended for use within the systems where implementing a full POSIX specification is not reasonable. For example, real-time embedded systems are typically resource-constrained, do not have shells, user interfaces, and OS kernels are often designed to run as a single process (with multiple threads). Such systems may only implement subsets of related functions defined by option groups.</p> <div class=line-block> <div class=line><br></div> </div> </div> <div class=section id=summary> <h2>Summary</h2> <ul class=simple> <li>The development of high-level programming languages like C, along with operating systems that abstract away hardware details, enabled software portability at the source code level.</li> <li>The POSIX standard emerged in 1988 to provide a portable interface specification for Unix-like operating systems, allowing programs to be compiled across different platforms.</li> <li>The POSIX standard has evolved over time, with the latest version being POSIX.1-2017 (IEEE Std 1003.1-2017).</li> <li>Modern Unix-like systems like Linux and <cite>*BSD</cite> do not strictly follow the POSIX standard, but rather use it as a guide.</li> <li>POSIX standardizes a C API (header files and functions), the shell, and utilities.</li> <li>POSIX-compliant systems are expected to implement mandatory options and may support additional optional features.</li> <li>Applications can check for POSIX feature availability at both compile-time and runtime using symbolic constants and system functions.</li> <li>For resource-constrained systems like real-time embedded platforms, POSIX allows for the implementation of subsets of the full specification through &quot;subprofile&quot; option groups.</li> </ul> <div class=line-block> <div class=line><br></div> </div> <!-- Links --> </div> </div> </div> <div class=article style="text-align: center; font-size: 1.1em; font-style: italic"> Found a <span style="color: red; font-weight: bold">bug</span> or <span style="color: red; font-weight: bold">typo</span>? Please, send me <a href=/pages/feedback/ >feedback</a> or submit a <a href=https://github.com/vorakl/vorakl.github.io/blob/master/src.docs/content/articles/posix.rst>PR on Github</a>. </div> <div class=article> <div class="well small"><h5>This is my personal blog. All ideas, opinions, examples, and other information that can be found here are my own and belong entirely to me. This is the result of my personal efforts and activities at my free time. It doesn't relate to any professional work I've done and doesn't have correlations with any companies I worked for, I'm currently working, or will work in the future.</h5></div> </div> </div> </div> </div> <footer> <div class=container> <div class=row> <div class=span5> <span class=pull-left> &copy; 2024 <a href=https://vorakl.com/pages/about/ >vorakl</a> All Rights Reserved </span> </div> <div class=span7> <div class=pull-right> Powered by <a href=https://github.com/getpelican/pelican>Pelican</a> and <a href=https://github.com/vorakl/aves>Aves</a> theme </div> </div> </div> </div> </footer> </div> </body> </html>